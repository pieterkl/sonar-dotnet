<p><code>ValueTask&lt;TResult&gt;</code> was introduced in .NET Core 2.0 as a struct capable of wrapping either a <code>TResult</code> or a
<code>Task&lt;TResult&gt;</code> to improve memory allocation. </p>
<p>A method returns a <code>ValueTask&lt;TResult&gt;</code> when it expects the operation to provide its result synchronously most of the time, in
which case no <code>Task&lt;TResult&gt;</code> is allocated. If, on the other hand, the operation finishes asynchronously a
<code>Task&lt;TResult&gt;</code> is allocated.</p>
<p><code>ValueTask</code> and <code>ValueTask&lt;TResult&gt;</code> cannot be consumed the same way as <code>Task</code> and
<code>Task&lt;TResult&gt;</code>. They wrap reusable objects which, if misused, can result in race conditions. <code>ValueTask /
ValueTask&lt;TResult&gt;</code> should <strong>never</strong> be used in the following ways:</p>
<ul>
  <li> <strong>Calling <code>await</code> multiple times on a <code>ValueTask / ValueTask&lt;TResult&gt;</code></strong>. The wrapped object may have
  been reused by another operation. This differs from <code>Task / Task&lt;TResult&gt;</code>, on which you can await multiple times and always get
  the same result. </li>
  <li> <strong>Calling <code>await</code> concurrently on a <code>ValueTask / ValueTask&lt;TResult&gt;</code></strong>. The underlying object is not
  thread safe. What's more, it has the same effect as awaiting multiple times a <code>ValueTask / ValueTask&lt;TResult&gt;</code>. This again differs
  from <code>Task / Task&lt;TResult&gt;</code>, which support concurrent <code>await</code>. </li>
  <li> <strong>Calling <code>.GetAwaiter().GetResult()</code> without checking if the operation completed</strong>. <code>IValueTaskSource /
  IValueTaskSource&lt;TResult&gt;</code> implementations are not required to block until the operation completes, thus it will create a race
  condition. On the other hand, <code>Task / Task&lt;TResult&gt;</code> blocks the call until the task completes. </li>
</ul>
<p>It is recommended to use <code>ValueTask / ValueTask&lt;TResult&gt;</code> either by calling "await" on the function returning it, optionally
calling <code>ConfigureAwait(false)</code> on it, or by calling <code>.AsTask()</code> on it.</p>
<p>In short, this rule raises an issue when:</p>
<ul>
  <li> a variable of type <code>ValueTask / ValueTask&lt;TResult&gt;</code> has multiple awaits, </li>
  <li> there is a call to <code>.GetAwaiter().GetResult()</code> </li>
</ul>
<p>Note that a good way to avoid multiple/concurrent <code>await</code> is to not store the result of a <code>ValueTask /
ValueTask&lt;TResult&gt;</code> method in a variable or field. However, this rule does not raise any issue in this context as it could create False
Positives.</p>
<h2>Noncompliant Code Example</h2>
<pre>
ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync();
int result = await vt;
int result2 = await vt; // Noncompliant, variable is awaited multiple times

int value = SomeValueTaskReturningMethodAsync().GetAwaiter().GetResult(); // Noncompliant, uses GetAwaiter().GetResult() when it's not known to be done
</pre>
<h2>Compliant Solution</h2>
<pre>
int result = await SomeValueTaskReturningMethodAsync();

int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false);

Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask();
</pre>
<h2>Exceptions</h2>
<p>This rule does not raise any issue when a <code>ValueTask / ValueTask&lt;TResult&gt;</code> is awaited multiple time in a loop.</p>
<h2>See</h2>
<ul>
  <li> <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/07/understanding-the-whys-whats-and-whens-of-valuetask/">Understanding the Whys,
  Whats, and Whens of ValueTask</a> </li>
</ul>

